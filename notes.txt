Timing:
    time ./main w 123 5 6 5 12
    trad pruning: 1.77s
    no pruning: 39.54s
    new pruning: 18.338s

Decisions decisions:
    ./main w 123 4 6 100 1
    no differences in play with length=6, auto length = 3, growth thresh=2

=======
Steven's notes on Jeff's Eyes

1. Test to see if we can really read at 60 fps from the capture card
2. Make sure that coords are stored at full size of the image, probably
3. Scale the coords and the image down as far as possible
4. Don't get 4 corners, get 2 corners and cut to avoid the image transformation
5. Simplify the black/white logic
6. Consider whether we can detect stars / detect specific colors and ignore stars
7. Better viz for debugging (specifically, I'd like to overlay what we see onto the board and the queue and the hold)
8. Timing logic for testing speed throughput
9. Can we get rid of the templates or something?
10. Can we use a simple theme and detect the background green color to ignore stars more easily?

remove math based on: perfect shape picture. "Perfect" pixel values.
pre-empt on cpp side.

=====
my gpu could hold 8e9 / 280 state objects. ~ 28.5 million
sizeof(State) = 280

could reduce to 272 --> ~29.4 million
could reduce to 264 --> ~30.3 million


=====
4 deep, pruning: ~94k comparisons per turn
4 deep, no pruning: 1.8e6 comparisons per turn.

=====


for HDMI config: switch's screen size is 96%
Run using while cwd is joycontrol.
    sudo python3

python3 tetris_ai_eyes.py --config hdmi_coords.config | ./main r i 4 6 999999999999 12 | sudo python3 ../switch-controller/bridge.py

Accurate random block generation model greatly improved play.
    +1 tetris percent
    never die

Remember
non-static reference members cause copy/move operations to be implicitly deleted.
List initializer interpretation
numeric limits...
    min() vs lowest()

Improved performance
    Using generators
    Not using the heap.

====

Not ref(move(*op_child)) because the return type of move is already an rvalue reference, more specifically:

remove_reference<T>::type&&

    workers.push_back(thread{
        &get_best_foreseeable_state_from_subtree,
        move(*op_child),
        ref(results),
        ref(results_mutex)
    });

/*
mutex: Exclusive access. Assuming everyone CAN be a writer.
shared_mutex: Non-exclusive access. Differentiates between readers and writers

unique_lock: Lock as a writer. Usable on mutex and shared_mutex.
shared_lock: Lock as a reader only. Usable on shared_mutex.
*/

python3 ../TetrisAI/tetris_ai_eyes.py --config ../TetrisAI/hdmi_coords.config | ../TetrisAI/main r i 4 6 999999999999 12 | sudo python3 run_controller_cli.py PRO_CONTROLLER
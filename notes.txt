Profile
Multi-thread
UI for playing
Surviving long without survival mode only

1093
    3 Deep
    return -(100 * num_holes) - (height_difference * height_difference * height_difference) - current_trench_penalty + current_cyan_reward;

2155
    4 deep
    return -(100 * num_holes) - (height_difference * height_difference * height_difference) - current_trench_penalty + current_cyan_reward;

After bug fix, didn't die, stopped at 9846 with 4 deep.


todo: make sure we can still do this.
survived 88k, 3 deep (really, 4 deep)


Remember
non-static reference members ruin copy/move semantics
Compiler implicitly deleting copy/move semantics
List initializer interpretation
min() vs lowest()

====

monitor for R/W seeds
vector<State> seeds;

monitor for R/W results
vector<State> results;

Tetris Worker:
    Thread
    while(seeds not empty){

        make the new stack with a seed
            process that seed

        public result;


    }

Why not ref(move()) ?
    workers.push_back(thread{
        &get_best_foreseeable_state_from_subtree,
        move(*op_child),
        ref(results),
        ref(results_mutex)
    });


/*
mutex: Exclusive access. Assuming everyone CAN be a writer.
shared_mutex: Non-exclusive access. Differentiates between readers and writers

unique_lock: Lock as a writer. Usable on mutex and shared_mutex.
shared_lock: Lock as a reader only. Usable on shared_mutex.
*/

c++ bug
vision whoosh white bug
have python dump all moves at once, keep things in buffer until down "presses" finish.
    python would have to keep track of how many things it sends, then listen for that many responses.
        define "terminal" commands.
dynamically change cycle count.
always run 3 deep. start running 4 deep, if you run out of time, fall back to 3 deep answer.
    how do 3 vs 4 deep answers differ?


Updated TODO:

1. Play faster
2. Fix the slam-whoosh board reading
3. With the new pruning, does he play the same game?



TIMING for games of small length is NOT representative anymore!!!

Decisions decisions:
    ./main w 123 4 6 100 1
    no differences in play with length=6, auto length = 3, growth thresh=2
    plays same game, but 4.6268420551x less comparisons on average

=======
Steven's notes on Jeff's Eyes

?. delete a lot of python.
1. Better viz
2. Remove the stability requirement (and simplify queue reading logic)
3. Speed (python? Arduino?)
4. Find a way to ignore stars
5. frame.read() in another thread???

remove math based on: perfect shape picture. "Perfect" pixel values.
pre-empt on cpp side.

=====
my gpu could hold 8e9 / 280 state objects. ~ 28.5 million
sizeof(State) = 280

could reduce to 272 --> ~29.4 million
could reduce to 264 --> ~30.3 million


=====
4 deep, pruning: ~94k comparisons per turn
4 deep, no pruning: 1.8e6 comparisons per turn.

=====


for HDMI config: switch's screen size is 96%
Run using while cwd is joycontrol.
    sudo python3

python3 tetris_ai_eyes.py --config hdmi_coords.config | ./main r i 4 6 999999999999 12 | sudo python3 ../switch-controller/bridge.py

Accurate random block generation model greatly improved play.
    +1 tetris percent
    never die

Remember
non-static reference members cause copy/move operations to be implicitly deleted.
List initializer interpretation
numeric limits...
    min() vs lowest()

Improved performance
    Using generators
    Not using the heap.

====

Not ref(move(*op_child)) because the return type of move is already an rvalue reference, more specifically:

remove_reference<T>::type&&

    workers.push_back(thread{
        &get_best_foreseeable_state_from_subtree,
        move(*op_child),
        ref(results),
        ref(results_mutex)
    });

/*
mutex: Exclusive access. Assuming everyone CAN be a writer.
shared_mutex: Non-exclusive access. Differentiates between readers and writers

unique_lock: Lock as a writer. Usable on mutex and shared_mutex.
shared_lock: Lock as a reader only. Usable on shared_mutex.
*/

python3 ../TetrisAI/tetris_ai_eyes.py --config ../TetrisAI/hdmi_coords.config | ../TetrisAI/main r i 4 6 999999999999 12 | sudo python3 run_controller_cli.py PRO_CONTROLLER